{
  "always_run_in_app" : true,
  "icon" : {
    "color" : "light-brown",
    "glyph" : "user-friends"
  },
  "name" : "Ajouter le contact à un groupe",
  "script" : "let text = {\n\n  'error': {\n    'fr-FR': \"Erreur\",\n    '*':     \"Error\"\n  },\n  \n  'error.noContactMatch': {\n    'fr-FR': `Aucun contact correspondant n'a été trouvé dans le compte par défaut. \n              Avez-vous sélectionné un contact sans nom ou organisation ou votre compte par défault est-il différent de iCloud ?`,\n    '*':     `No matching contact was found in the default contact account.\n              Have you selected an account with at least a first name, last name or organization ou is your default\n              account not the iCloud one?`\n  },\n  'error.multipleContactMatch': {\n    'fr-FR': `Plusieurs contacts portent le même nom et prénom dans le compte par défaut.`,\n    '*':     `Multiple contacts seems to share first name, last name and organization in the default contact account.`\n  },\n  'error.isDefaultICloud': {\n    'fr-FR': `Erreur. Verifiez que votre compte par défault pour les contacts est bien iCloud.`,\n    '*':     `Error. Please check default contact account is iCloud.`\n  },\n  \n  \n  'ok': {\n    'fr-FR': \"OK\",\n    '*':     \"OK\"\n  },\n  'cancel': {\n    'fr-FR': \"Annuler\",\n    '*':     \"Cancel\"\n  },\n\n\n  \/\/ Use this as a template for localization\n  '__': {\n    'fr-FR': \"\",\n    '*':     \"\"\n  }\n};\n\n\/\/ ===== UI UTILITIES\n\nObject.prototype.i18n = function (key) {\n  let langs = Device.preferredLanguages();\n  langs.push('*');\n  \n  if ( 'undefined' === typeof this[key] ) {\n    console.log(`Missing key ${key}`);\n    Script.complete();\n  }\n  \n  let msg;\n  while ( 'undefined' === typeof msg && (langs.length > 0) ) {\n    msg = this[key][langs.shift()];\n  }\n  \n  return msg;\n};\n\n\/\/ ===== ENTRY POINT\n\nlet allContact = [];\n\n\/\/ We can be called from the share sheet or callback-url\n\nif ( 0 === args.all.length ) {\n  \/\/ CASE 1: no arguments from share sheet, check if we are called from XCallback URL\n  allContact = buildInputFromCallbackURL();\n}\nelse {\n  \/\/ CASE 2: We were called from share sheet, just get the VCards and convert them to internal object\n  allContact = buildInputFromShareSheet()\n}\n\n\/\/ Currently share sheet only provide a single contact, but just try to be safe \n\/\/ by looping on all items, just in case.\n\/\/\nfor ( contactProps of allContact ) {\n  if ( null !== contactProps.org && ('' === contactProps.firstName) ) {\n    \/\/ Error: Only Cie name, no family name we might not find proper contact\n    \/\/ TODO: we shall expose tome error here\n  }\n  \n  let contacts = await findContacts(contactProps);\n  \n  if ( contacts.length === 0 ) {\n    \/\/ No match found\n    let alert = createAlertDialog(\n      text.i18n('error'), \n      text.i18n('error.noContactMatch'), \n      text.i18n('cancel')\n    );\n    alert.presentAlert();\n  }\n  else if ( contacts.length > 1 ) {\n    \/\/ More than one match\n    let alert = createAlertDialog(\n      text.i18n('error'), \n      text.i18n('error.multipleContactMatch'), \n      text.i18n('cancel')\n    );\n    alert.presentAlert();\n  }\n  else {\n    \/\/ Only one match\n    let container = await ContactsContainer.default();\n    \n    let groupSelectedHandler = (group) => {\n      console.log(`Group select: ${group}`);\n      if ( null !== group ) {\n        addContactToGroup(contacts[0], group, container);\n      }\n    };\n    \n    await selectContactGroup(container, groupSelectedHandler);\n  }\n}\n\n\/\/ ===== INPUT HANDLING\n\n\/** Extract contact first name\/last name from input and build a contact summary.\n * \n * We expect to have two parameters from URL:\n * - `fn` for base64-encoded firstname\n * - `ln` for base64-encoded lastname\n * - `o`  for base64-encoded organization name\n *\/\nfunction buildInputFromCallbackURL() {\n  let params = URLScheme.allParameters();\n  \n  let lastnameB64  = params[\"ln\"];\n  let firstnameB64 = params[\"fn\"];\n  let orgB64       = params[\"o\"];\n  \n  \/\/ We do not use this\n  \/\/ let baseURL = params[\"x-success\"]\n  \n  let lastnameData  = Data.fromBase64String(lastnameB64);\n  let firstnameData = Data.fromBase64String(firstnameB64);\n  let orgData       = Data.fromBase64String(orgB64);\n  \n  let lastname  = lastnameData.toRawString();\n  let firstname = firstnameData.toRawString();\n  let org       = org.toRawString();\n  \n  console.log(`Importing contact:\\n${firstname} ${lastname} - ORG: ${org}`);\n  \n  let contact = ContactProp();\n  contact.firstName = firstname;\n  contact.lastName  = lastname;\n  contact.org       = org;\n  \n  return [ contact ];\n}\n\n\n\/** Extract contact first\/last nam from argument list provided by share sheet\n *\/\nfunction buildInputFromShareSheet() {\n  return args.plainTexts.map((arg) => {\n    return getContactFromVCard(arg);\n  });\n}\n\n\n\/\/ ===== CONTACT INTERACTION\n\n\/** Internal contact summary object.\n *\/\nfunction ContactProp() {\n  let contact = {\n    org: null, \/\/ Not provided in Contact object\n    fn:  null, \/\/ Full display name, formatted for display\n    firstName: '',\n    lastName: ''\n  };\n  \n  return contact;\n};\n\n\n\/** As share sheet provide a simple VCard we have to find matching contact ourselves.\n *\n * Without internal Contact.id property value we have to make a guess \n * on the matching contact.\n *\n * This function just parses VCard to get main identification properties. \n *\/\nfunction getContactFromVCard(text) {\n  let contact = ContactProp();\n  \n  let singleValueRE = \/^(FN|ORG):([^;]+);?$\/i;\n  let namesRE = \/^N:(.+)$\/i;\n  let lines = text.split(\/\\r\\n|\\r|\\n\/);\n  \n   lines.forEach((line) => {\n     if ( singleValueRE.test(line) ) {\n       let matches = line.match(singleValueRE);\n       let key   = matches[1].toLowerCase().trim();\n       let value = matches[2].trim();\n       \n       contact[key] = value;\n     }\n     else if ( namesRE.test(line) ) {\n       let matches = line.match(namesRE);\n       let parts = matches[1].split(';');\n       let lastName  = parts[0].trim();\n       let firstName = parts[1].trim();\n       \n       contact['firstName'] = firstName;\n       contact['lastName']  = lastName;\n     }\n   });\n  \n  return contact;  \n}\n\n\n\/** Using core contact properties try to find matching contact.\n *\/\nasync function findContacts(props) {\n  let container = await ContactsContainer.default();\n  let allContacts = await Contact.all([ container ]); \n  \n  let matches = allContacts.filter((current) => {\n    let familyName = ( current.familyName )       ? current.familyName.trim() : '';\n    let givenName  = ( current.givenName )        ? current.givenName.trim()  : '';\n    let orgName    = ( current.organizationName ) ? current.organizationName.trim()  : '';\n    \n    let sameFamilyName = 0 === props.lastName.localeCompare(familyName);\n    let sameGivenName  = 0 === props.firstName.localeCompare(givenName);\n    let sameOrgName    = 0 === props.org.localeCompare(orgName);\n    \n    let isMatching = sameFamilyName && sameGivenName && sameOrgName;\n    \n    return isMatching;\n  });\n  \n  return matches;\n}\n\n\n\/\/ ===== UI UTILITIES\n\n\/** Create a simple alert dialog.\n *\/\nfunction createAlertDialog(title, message, cancelLabel) {\n  let dialog = new Alert();\n  \n  dialog.title = title;\n  dialog.message = message;\n  \n  dialog.addCancelAction(cancelLabel);\n  \n  return dialog;\n}\n\n\n\/\/ ===== TABLE OF GROUPS\n\n\/** Create a simple UITableRow for a group\n *\n * @param group \n *        ContactsGroup object\n * @param selectFn \n *        Function to call when group is selected `(group: ContactsGroup) => { ... }`\n *\/\nasync function createGroupRow(group, selectFn) { \n  let row = new UITableRow();\n  row.height = 50;\n\n  let members = await Contact.inGroups([group]);\n  \n  let nameCell = UITableCell.text(group.name);\n  nameCell.leftAligned();\n  \n  let countCell = UITableCell.text(`${ members.length } contacts`)\n  countCell.rightAligned();\n  \n  row.addCell(nameCell);\n  row.addCell(countCell);\n\n  row.onSelect = selectFn;\n  \n  return row;\n}\n\n\n\/** Build a UITable to present a list of ContactsGroup.\n *\/\nasync function createGroupTable(groups, selectFn) {\n  let table = new UITable();\n  \n  for ( group of groups ) {\n    let row = await createGroupRow(group, selectFn);\n    table.addRow(row);\n  }\n  \n  return table;\n}\n\n\n\/\/ ===== CONTACT GROUP UTILITY\n\n\/** Order an array of ContactsGroup by their name.\n *\/\nfunction orderGroups(groups) {\n  groups.sort(\n    (g1, g2) => { return g1.name.localeCompare(g2.name); }\n  );\n  \n  return groups;\n}\n\n\n\/** Show a list of groups and ask user to select one\n *\n * @param container\n *        The ContactsContainer that groups are part of.\n * @param selectedFn\n *.       Function that will be called when a group gets selected.\n *.       This function accepts a single ContactsGroup parameter.\n *\/\nasync function selectContactGroup(container, selectedFn) {\n  let allGroups = await ContactsGroup.all([ container ]);\n  \n  let orderedGroups = orderGroups(allGroups);\n  \n  \/\/ We build a small function to map row number to group object\n  \/\/ as this is the kind of parameter expected by the selectedFn parameter.\n  let groupSelectionHandler = (index) => {\n    let group = orderedGroups[index];\n    selectedFn(group);\n  };\n  \n  let groupTable = await createGroupTable(orderedGroups, groupSelectionHandler);\n  \n  groupTable.present();\n}\n\n\n\/** Add the specified contact to the specified group.\n *\n * @param contact: Contact\n * @param group: ContactsGroup\n * @param container: ContactsGroup\n *\/\nfunction addContactToGroup(contact, group, container) {\n  group.addMember(contact)\n  \n  Contact.persistChanges()\n  .then((data) => {\n    console.log(`Contact ${ contact.familyName } added to group ${ group.name }.`); \n    Script.complete();\n  })\n  .catch((error) => {\n    console.log(`Failed to add contact to group. ${error}`);\n    let alert = createAlertDialog(text.i18n('error'), text.i18n('error.isDefaultICloud'), text.i18n('ok'));\n\n    alert.present().then(\n      () => { Script.complete(); }, \n      () => { Script.complete(); }\n    );\n  });\n}\n\n\n",
  "share_sheet_inputs" : [
    "plain-text",
    "url",
    "file-url"
  ]
}