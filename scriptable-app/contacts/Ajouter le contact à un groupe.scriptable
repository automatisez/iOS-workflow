{
  "always_run_in_app" : true,
  "icon" : {
    "color" : "light-brown",
    "glyph" : "user-friends"
  },
  "name" : "Ajouter le contact à un groupe",
  "script" : "\/\/ ===== UI UTILITIES\n\n\/** Create a simple alert dialog.\n *\/\nfunction createAlertDialog(title, message, cancelLabel) {\n  let dialog = new Alert();\n  \n  dialog.title = title;\n  dialog.message = message;\n  \n  dialog.addCancelAction(cancelLabel);\n  \n  return dialog;\n}\n\n\n\/** Create a simple UITableRow for a group\n *\n * @param group \n *        ContactsGroup object\n * @param selectFn \n *        Function to call when group is selected `(group: ContactsGroup) => { ... }`\n *\/\nasync function createGroupRow(group, selectFn) { \n  let row = new UITableRow();\n  row.height = 50;\n\n  let members = await Contact.inGroups([group]);\n  \n  let nameCell = UITableCell.text(group.name);\n  nameCell.leftAligned();\n  \n  let countCell = UITableCell.text(`${ members.length } contacts`)\n  countCell.rightAligned();\n  \n  row.addCell(nameCell);\n  row.addCell(countCell);\n\n  row.onSelect = selectFn;\n  \n  return row;\n}\n\n\n\/** Build a UITable to present a list of ContactsGroup.\n *\/\nasync function createGroupTable(groups, selectFn) {\n  let table = new UITable();\n  \n  for ( group of groups ) {\n    let row = await createGroupRow(group, selectFn);\n    table.addRow(row);\n  }\n  \n  return table;\n}\n\n\n\/\/ ===== CONTACT GROUP UTILITY\n\n\/** Order an array of ContactsGroup by their name.\n *\/\nfunction orderGroups(groups) {\n  groups.sort(\n    (g1, g2) => { return g1.name.localeCompare(g2.name); }\n  );\n  \n  return groups;\n}\n\n\n\/\/ ===== CONTACT INTERACTION\n\nfunction ContactProp() {\n  let contact = {\n    org: null, \/\/ Not provided in Contact object\n    fn:  null, \/\/ Full display name, formatted for display\n    firstName: '',\n    lastName: ''\n  };\n  \n  return contact;\n};\n\n\nfunction getContactFromVCard(text) {\n  let contact = ContactProp();\n  \n  let singleValueRE = \/^(FN|ORG):(.+)$\/i;\n  let namesRE = \/^N:(.+)$\/i;\n  let lines = text.split(\/\\r\\n|\\r|\\n\/);\n  \n   lines.forEach((line) => {\n     if ( singleValueRE.test(line) ) {\n       let matches = line.match(singleValueRE);\n       let key   = matches[1].toLowerCase().trim();\n       let value = matches[2].trim();\n       \n       contact[key] = value;\n     }\n     else if ( namesRE.test(line) ) {\n       let matches = line.match(namesRE);\n       let parts = matches[1].split(';');\n       let lastName  = parts[0].trim();\n       let firstName = parts[1].trim();\n       \n       contact['firstName'] = firstName;\n       contact['lastName']  = lastName;\n     }\n   });\n \n  return contact;  \n}\n\n\nasync function findContacts(props) {\n  let container = await ContactsContainer.default();\n  let allContacts = await Contact.all([ container ]);\n  \n  let matches = allContacts.filter((current) => {\n    let familyName = ( current.familyName ) ? current.familyName.trim() : '';\n    let givenName  = ( current.givenName )  ? current.givenName.trim()  : '';\n    \n    let hasFamilyName = familyName.length > 0 && 0 === props.lastName.localeCompare(familyName);\n    let hasGivenName  = givenName.length > 0 && 0 === props.firstName.localeCompare(givenName);\n    \n    let isMatching = hasFamilyName && hasGivenName;\n    \n    return isMatching;\n  });\n  \n  return matches;\n}\n\n\nasync function selectContactGroup(container, selectedFn) {\n  let allGroups = await ContactsGroup.all([ container ]);\n  \n  let orderedGroups = orderGroups(allGroups);\n  \n  \/\/ We build a small function to map row number to group object\n  \/\/ as this is the kind of parameter expected by the selectedFn parameter.\n  let groupSelectionHandler = (index) => {\n    let group = orderedGroups[index];\n    selectedFn(group);\n  };\n  \n  let groupTable = await createGroupTable(orderedGroups, groupSelectionHandler);\n  \n  groupTable.present();\n}\n\n\nfunction addContactToGroup(contact, group, container) {\n  group.addMember(contact)\n  \n  Contact.persistChanges()\n  .then((data) => {\n    console.log(`Contact ${ contact.familyName } added to group ${ group.name }.`); \n    Script.complete();\n  })\n  .catch((error) => {\n    console.log(`Failed to add contact to group. ${error}`);\n    let alert = createAlertDialog(\"Erreur\", \"Erreur. Verifiez que votre compte par défault pour les contacts est bien iCloud.\", \"OK\")\n    alert.present().then(\n      () => { Script.complete(); }, \n      () => { Script.complete(); }\n    );\n  });\n}\n\n\n\n\/\/ -----\n\n\nlet allContact = [];\n\n\/\/ We can be called from the share sheet of callback-url\n\nif ( 0 === args.all.length ) {\n  \/\/ CASE 1: no arguments from share sheet, check if we are called from XCallback URL\n  allContact = buildInputFromCallbackURL();\n}\nelse {\n  \/\/ CASE 2: We were called from share sheet, just get the VCards and convert them to internal object\n  \n  allContact = args.plainTexts.map((arg) => {\n    return getContactFromVCard(arg);\n  });\n}\n\n\nfor ( contactProps of allContact ) {\n  if ( null !== contactProps.org && ('' === contactProps.firstName) ) {\n    \/\/ Error: Only Cie name, no family name we might not find proper contact\n  }\n  \n  let contacts = await findContacts(contactProps);\n  \/\/ TRACE: console.log(contacts);\n  \n  if ( contacts.length === 0 ) {\n    \/\/ No match found\n    let alert = createAlertDialog(\n      \"Erreur\", \n      `Aucun contact correspondant n'a été trouvé dans le compte par défaut. \n      Avez-vous sélectionné un contact entreprise ou votre compte par défault est-il différent de iCloud ?`, \n      \"Annuler\"\n    );\n    alert.presentAlert();\n  }\n  else if ( contacts.length > 1 ) {\n    \/\/ More than one match\n    let alert = createAlertDialog(\n      \"Erreur\", \n      `Plusieurs contacts portent le même nom et prénom dans le compte par défaut.`, \n      \"Annuler\"\n    );\n    alert.presentAlert();\n  }\n  else {\n    \/\/ Only one match\n    let container = await ContactsContainer.default();\n    \n    let groupSelectedHandler = (group) => {\n      console.log(`Group select: ${group}`);\n      if ( null !== group ) {\n        addContactToGroup(contacts[0], group, container);\n      }\n    };\n    \n    await selectContactGroup(container, groupSelectedHandler);\n  }\n}\n\n\/\/ ===== INPUT HANDLING\n\n\/** Extract contact first name\/last name from input and build a contact summary.\n * \n * We expect to have two parameters from URL:\n * - `fn` for base64-encoded firstname\n * - `ln` for base64-encoded lastname\n *\/\nfunction buildInputFromCallbackURL() {\n  let params = URLScheme.allParameters();\n  \n  let lastnameB64  = params[\"ln\"];\n  let firstnameB64 = params[\"fn\"];\n  \n  \/\/ We do not use this\n  \/\/ let baseURL = params[\"x-success\"]\n  \n  let lastnameData  = Data.fromBase64String(lastnameB64);\n  let firstnameData = Data.fromBase64String(firstnameB64);\n  \n  let lastname  = lastnameData.toRawString();\n  let firstname = firstnameData.toRawString();\n  \n  console.log(`Importing contact:\\n${firstname} ${lastname}`);\n  \n  let contact = ContactProp();\n  contact.firstName = firstname;\n  contact.lastName  = lastname;\n  \n  return [ contact ];\n}\n",
  "share_sheet_inputs" : [
    "plain-text",
    "url",
    "file-url"
  ]
}